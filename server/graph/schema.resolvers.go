package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"github.com/9ssi7/music-recommender/app/command"
	"github.com/9ssi7/music-recommender/app/query"
	"github.com/9ssi7/music-recommender/server/graph/model"
	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserListDto, error) {
	res, err := r.app.Commands.UserCreate(ctx, command.UserCreateCmd{
		Email:          input.Email,
		UserName:       input.UserName,
		FavoriteGenres: input.FavoriteGenres,
	})
	if err != nil {
		return nil, err
	}
	return &model.UserListDto{
		ID:       res.Dto.Id,
		UserName: res.Dto.UserName,
		Email:    res.Dto.Email,
	}, nil
}

// CreateGenre is the resolver for the createGenre field.
func (r *mutationResolver) CreateGenre(ctx context.Context, input model.CreateGenreInput) (*model.GenreListDto, error) {
	res, err := r.app.Commands.GenreCreate(ctx, command.GenreCreateCommand{
		Name: input.Name,
	})
	if err != nil {
		return nil, err
	}
	return &model.GenreListDto{
		ID:   res.Dto.Id,
		Name: res.Dto.Name,
	}, nil
}

// DeleteGenre is the resolver for the deleteGenre field.
func (r *mutationResolver) DeleteGenre(ctx context.Context, id uuid.UUID) (bool, error) {
	_, err := r.app.Commands.GenreDelete(ctx, command.GenreDeleteCommand{
		Id: id,
	})
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateSong is the resolver for the createSong field.
func (r *mutationResolver) CreateSong(ctx context.Context, input model.CreateSongInput) (*model.SongListDto, error) {
	res, err := r.app.Commands.SongCreate(ctx, command.SongCreateCommand{
		Title:   input.Title,
		Artist:  input.Artist,
		GenreId: input.GenreID,
	})
	if err != nil {
		return nil, err
	}
	return &model.SongListDto{
		ID:     res.Dto.Id,
		Title:  res.Dto.Title,
		Artist: res.Dto.Artist,
	}, nil
}

// DeleteSong is the resolver for the deleteSong field.
func (r *mutationResolver) DeleteSong(ctx context.Context, id uuid.UUID) (bool, error) {
	_, err := r.app.Commands.SongDelete(ctx, command.SongDeleteCommand{
		Id: id,
	})
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarkSongAsListened is the resolver for the markSongAsListened field.
func (r *mutationResolver) MarkSongAsListened(ctx context.Context, userID uuid.UUID, songID uuid.UUID) (bool, error) {
	_, err := r.app.Commands.SongMarkListened(ctx, command.SongMarkListenedCommand{
		UserId: userID,
		Id:     songID,
	})
	if err != nil {
		return false, err
	}
	return true, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, email string) (*model.UserListDto, error) {
	res, err := r.app.Queries.UserGetByEmail(ctx, query.UserGetByEmailQuery{
		Email: email,
	})
	if err != nil {
		return nil, err
	}
	return &model.UserListDto{
		ID:       res.Dto.Id,
		UserName: res.Dto.UserName,
		Email:    res.Dto.Email,
	}, nil
}

// Genres is the resolver for the genres field.
func (r *queryResolver) Genres(ctx context.Context) ([]*model.GenreListDto, error) {
	res, err := r.app.Queries.GenreList(ctx, query.GenreListQuery{})
	if err != nil {
		return nil, err
	}
	result := make([]*model.GenreListDto, 0, len(res.Dtos))
	for _, dto := range res.Dtos {
		result = append(result, &model.GenreListDto{
			ID:   dto.Id,
			Name: dto.Name,
		})
	}
	return result, nil
}

// Genre is the resolver for the genre field.
func (r *queryResolver) Genre(ctx context.Context, id uuid.UUID) (*model.GenreListDto, error) {
	res, err := r.app.Queries.GenreView(ctx, query.GenreViewQuery{
		Id: id,
	})
	if err != nil {
		return nil, err
	}
	return &model.GenreListDto{
		ID:   res.Dto.Id,
		Name: res.Dto.Name,
	}, nil
}

// Songs is the resolver for the songs field.
func (r *queryResolver) Songs(ctx context.Context) ([]*model.SongListDto, error) {
	res, err := r.app.Queries.SongList(ctx, query.SongListQuery{})
	if err != nil {
		return nil, err
	}
	result := make([]*model.SongListDto, 0, len(res.Dtos))
	for _, dto := range res.Dtos {
		result = append(result, &model.SongListDto{
			ID:     dto.Id,
			Title:  dto.Title,
			Artist: dto.Artist,
		})
	}
	return result, nil
}

// Song is the resolver for the song field.
func (r *queryResolver) Song(ctx context.Context, id uuid.UUID) (*model.SongListDto, error) {
	res, err := r.app.Queries.SongView(ctx, query.SongViewQuery{
		Id: id,
	})
	if err != nil {
		return nil, err
	}
	return &model.SongListDto{
		ID:     res.Dto.Id,
		Title:  res.Dto.Title,
		Artist: res.Dto.Artist,
	}, nil
}

// SongsByGenre is the resolver for the songsByGenre field.
func (r *queryResolver) SongsByGenre(ctx context.Context, genreID uuid.UUID) ([]*model.SongListDto, error) {
	res, err := r.app.Queries.SongListByGenre(ctx, query.SongListByGenreQuery{
		GenreId: genreID,
	})
	if err != nil {
		return nil, err
	}
	result := make([]*model.SongListDto, 0, len(res.Dtos))
	for _, dto := range res.Dtos {
		result = append(result, &model.SongListDto{
			ID:     dto.Id,
			Title:  dto.Title,
			Artist: dto.Artist,
		})
	}
	return result, nil
}

// SongsRecommendation is the resolver for the songsRecommendation field.
func (r *queryResolver) SongsRecommendation(ctx context.Context, userID uuid.UUID) ([]*model.SongListDto, error) {
	res, err := r.app.Queries.SongListUserRecommendation(ctx, query.SongListUserRecommendationQuery{
		UserId: userID,
	})
	if err != nil {
		return nil, err
	}
	result := make([]*model.SongListDto, 0, len(res.Dtos))
	for _, dto := range res.Dtos {
		result = append(result, &model.SongListDto{
			ID:     dto.Id,
			Title:  dto.Title,
			Artist: dto.Artist,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
